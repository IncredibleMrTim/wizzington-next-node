"use client";

import omit from "lodash/omit";
import { useMemo, useState } from "react";
import { ZodError } from "zod";
import { Prisma } from "@prisma/client";
import ReactDOMServer from "react-dom/server";

import PayPalButton, {
  OrderResponseBody,
} from "@/components/payPal/payPalButton/PayPalButton";
import PayPalProvider from "@/components/payPal/payPalProvider/PayPalProvider";
import { createOrder } from "@/actions/order.actions";
import { sendEmail } from "@/utils/email";
import { OrderEmailTemplate } from "@/components/emailTemplates/orderEmailTemplate";
import {
  onValidationProps,
  ProductField,
} from "@/components/productFields/ProductField";
import { OrderProduct } from "@/lib/types";
import { useProductStore, useOrderStore } from "@/stores";

interface ProductSpecificationProps {
  fields: Array<Record<string, any>>;
}

export const ProductSpecification = ({ fields }: ProductSpecificationProps) => {
  const requiredFieldNames = fields
    .filter((f) => Object.values(f)[0].required)
    .map((f) => Object.keys(f)[0]);

  // States
  const [fieldErrors, setFieldErrors] = useState<{
    [key: string]: ZodError | null;
  }>({});

  // Selectors
  const currentProduct = useProductStore((state) => state.currentProduct);
  const currentOrder = useOrderStore((state) => state.currentOrder);
  const setCurrentOrder = useOrderStore((state) => state.setCurrentOrder);
  const updateOrderProduct = useOrderStore((state) => state.updateOrderProduct);

  const currentOrderProduct = currentOrder?.orderProducts.find(
    (product: OrderProduct) => product.productId === currentProduct?.id
  );

  // check if the order is valid before we show the PayPal button
  const isValidOrderProduct = useMemo(
    () =>
      Object.keys(omit(currentOrderProduct, "productId")).length >=
        requiredFieldNames.length &&
      Object.values(fieldErrors).every((error) => error === null),
    [currentOrderProduct, fieldErrors, requiredFieldNames]
  );

  /*
   * Handle successful PayPal payment
   * @param orderDetails - The details of the order response from PayPal
   */
  const handleSuccess = async (orderDetails: OrderResponseBody) => {
    if (isValidOrderProduct && currentOrder) {
      await createOrder({
        customer_name: currentOrder.customerName || undefined,
        customer_email: currentOrder.customerEmail || undefined,
        customer_phone: currentOrder.customerPhone || undefined,
        notes: currentOrder.notes || undefined,
        products: currentOrder.orderProducts.map((product) => ({
          productId: product.productId,
          name: product.productName,
          quantity: product.quantity,
          price: Number(product.price),
        })),
      });

      await sendEmail({
        to: process.env.SMTP_EMAIL || "",
        subject: "New Order Received",
        html: ReactDOMServer.renderToStaticMarkup(
          OrderEmailTemplate(orderDetails, currentOrder)
        ),
      });
    }
  };

  /*
   * Handle validation of product fields
   * @param fieldName - The name of the field being validated
   * @param value - The value of the field being validated
   * @param type - The type of validation field
   * @returns true if there is an error, false otherwise
   */
  const handleValidation = ({ fieldName, value, type }: onValidationProps) => {
    if (type === "error") {
      setFieldErrors((prev) => ({
        ...prev,
        [fieldName]: value as ZodError,
      }));

      return true;
    }

    // remove field errors if the field is valid
    setFieldErrors((prev) => {
      const updated = { ...prev };
      delete updated[fieldName];
      return updated;
    });

    // If there is no order, create a new one
    if (!currentOrder) {
      // Create a partial order - id and timestamps will be generated by the database
      const newOrder = {
        orderProducts: [],
        status: "pending",
        customerName: null,
        customerEmail: null,
        customerPhone: null,
        totalAmount: new Prisma.Decimal(0),
        notes: null,
        id: "",
        createdAt: new Date(),
        updatedAt: new Date(),
      };
      setCurrentOrder(newOrder);
    }

    // Add or update the product in the order
    const parsedValue = parseInt(value.toString(), 10);
    updateOrderProduct({
      productId: currentProduct?.id || "",
      name: currentProduct?.name || "",
      uid: currentOrderProduct?.id || crypto.randomUUID(),
      price: currentProduct?.price || 0,
      updates: { [fieldName]: isNaN(parsedValue) ? value : parsedValue },
    });

    return false;
  };

  return (
    <div className="flex flex-col gap-8">
      <div className="flex flex-col gap-4">
        <h1 className="text-2xl font-bold">Order Details</h1>
        <p>
          Fill out the form below to place your order for {currentProduct?.name}
        </p>
        <p>
          Nunc porttitor porttitor ante vitae suscipit. Donec pretium purus et
          est aliquet tempor. Mauris maximus et dolor pulvinar fringilla. In
          dignissim eros porta felis laoreet mollis. Aliquam erat volutpat.
          Etiam mollis ex ut quam pretium, eget ullamcorper erat blandit. In a
          libero eget orci malesuada ornare. Praesent vulputate eros quis quam
          aliquet, pulvinar luctus justo aliquam.
        </p>
      </div>

      <div className="flex flex-wrap flex-row gap-y-4 w-full">
        {fields.map((field, index) => {
          const [name, props] = Object.entries(field)[0];

          return (
            <div
              className={`${props.span ? "w-full" : "w-1/2"} py-2 px-4`}
              key={props.name || index}
            >
              <ProductField
                {...props}
                name={name}
                onValidation={handleValidation}
              />
            </div>
          );
        })}
      </div>

      <PayPalProvider>
        <PayPalButton
          amount={currentProduct?.price?.toString() || "0"}
          onSuccess={handleSuccess}
          disabled={!isValidOrderProduct || !currentOrderProduct}
        />
      </PayPalProvider>
    </div>
  );
};
